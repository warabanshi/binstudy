gcc a.c consist by some steps
    1. a.c -> a.s
    2. a.s -> a.o
    3. a.o -> a.out
you can see these steps what it did the command by
    $ gcc -v a.c

-----------------------------------------------------

if you want to see what include in a.out of ELF format.
it is possible in
    $ readelf -a a.out

-----------------------------------------------------
ELF64 test

-- tiny.s
BITS 64
GLOBAL main
SECTION .text
main:
    mov     rax, 42
    ret
 
above assembly code expects return 42 by below commands

$ nasm -f elf64 tiny.s
$ gcc -Wall -s tiny.o
$ ./a.out; echo $?
42

-----------------------------------------------------

refer to the difference from 32bit and 64bit systemcall below
    http://www.mztn.org/lxasm64/x86_x64_table.html

-----------------------------------------------------

elf specificication which you using is /usr/include/linux/elf.h

-----------------------------------------------------

how to retrieve program header from binary

ex)
$ readelf -h a.out
ELF Header:
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF64
Data:                              2's complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              EXEC (Executable file)
Machine:                           Advanced Micro Devices X86-64
Version:                           0x1
Entry point address:               0x4000e0
Start of program headers:          64 (bytes into file)
Start of section headers:          272 (bytes into file)
Flags:                             0x0
Size of this header:               64 (bytes)
Size of program headers:           56 (bytes)
Number of program headers:         2
Size of section headers:           64 (bytes)
Number of section headers:         4
Section header string table index: 3

** you can see the program header offset and size from above result.
** those are 56byte(size of program header) and 64(offset of rogram header).
** then you should enter below od command. it output the program header.

$ od -j 64 -N 56 -t x1 a.out
0000100 01 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00
0000120 00 00 40 00 00 00 00 00 00 00 40 00 00 00 00 00
0000140 ec 00 00 00 00 00 00 00 ec 00 00 00 00 00 00 00
0000160 00 00 20 00 00 00 00 00
0000170

-----------------------------------------------------

JIT systemcall version

if you want to use putchar function with no glibc when you may use
write systemcall with strout


-----------------------------------------------------

when execute jit.out, return the message 'killed'.
why it happend?
first, compare with a.out generated by tiny3.s and elf64base.asm.

$ nasm -f elf64 tiny3.s
$ gcc -Wall -s -nostartfiles tiny3.o
$ ./a.out
$ objdump -d a.out

it returns 

0000000000400250 <.text>:
400250:       b8 3c 00 00 00          mov    $0x3c,%eax
400255:       bf 2a 00 00 00          mov    $0x2a,%edi
40025a:       0f 05                   syscall

$ nasm -f bin -o a.out elf64base.asm
$ chmod a+x a.out
$ ./a.out

it returns no statements.
you can see the header size by '$ bvi a.out' and find 'B8 3C' which starts
main statement. it is 0x78.
so you can also see statements omitting header in ndisasm
  $ ndisasm -b 64 -e 0x78 jit.out

well, i execute proto7.py with most simple bf code.
it ndisasm is returns 

$ ndisasm -b 64 -e 0x78 jit.out

00000000  53                push rbx
00000001  48BB00A9AC010000  mov rbx,0x1aca900
         -0000
0000000B  FE03              inc byte [rbx]
0000000D  5B                pop rbx
0000000E  C3                ret

perhups, i have to glub the memory in ELF .bss section.
above result glub the memory in python code.
how do i get it?


--------------------------------------------------------

.comm is gas syntax
.bss is nasm syntax
they have same means

--------------------------------------------------------

$ nasm -f bin -o a.out nasm.asm
$ objdump -d a.out

if you want to getting the disassembled code by objdump in above.
you have to implement section header in nasm.asm.

--------------------------------------------------------

you can easy to use httpd server in python

$ python -m SimpleHTTPServer 8080

*port is option

--------------------------------------------------------

if set the size more than filesize in memsize of ELF program header
then the memory over the size of file areas are considered .bss area

by Linker & Loader P.69

-> it is incorrect
