gcc a.c consist by some steps
    1. a.c -> a.s
    2. a.s -> a.o
    3. a.o -> a.out
you can see these steps what it did the command by
    $ gcc -v a.c

-----------------------------------------------------

if you want to see what include in a.out of ELF format.
it is possible in
    $ readelf -a a.out

-----------------------------------------------------
ELF64 test

-- tiny.s
BITS 64
GLOBAL main
SECTION .text
main:
    mov     rax, 42
    ret
 
above assembly code expects return 42 by below commands

$ nasm -f elf64 tiny.s
$ gcc -Wall -s tiny.o
$ ./a.out; echo $?
42

-----------------------------------------------------

refer to the difference from 32bit and 64bit systemcall below
    http://www.mztn.org/lxasm64/x86_x64_table.html

-----------------------------------------------------

elf specificication which you using is /usr/include/linux/elf.h

-----------------------------------------------------

how to retrieve program header from binary

ex)
$ readelf -h a.out
ELF Header:
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF64
Data:                              2's complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              EXEC (Executable file)
Machine:                           Advanced Micro Devices X86-64
Version:                           0x1
Entry point address:               0x4000e0
Start of program headers:          64 (bytes into file)
Start of section headers:          272 (bytes into file)
Flags:                             0x0
Size of this header:               64 (bytes)
Size of program headers:           56 (bytes)
Number of program headers:         2
Size of section headers:           64 (bytes)
Number of section headers:         4
Section header string table index: 3

** you can see the program header offset and size from above result.
** those are 56byte(size of program header) and 64(offset of rogram header).
** then you should enter below od command. it output the program header.

$ od -j 64 -N 56 -t x1 a.out
0000100 01 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00
0000120 00 00 40 00 00 00 00 00 00 00 40 00 00 00 00 00
0000140 ec 00 00 00 00 00 00 00 ec 00 00 00 00 00 00 00
0000160 00 00 20 00 00 00 00 00
0000170

-----------------------------------------------------

JIT systemcall version

if you want to use putchar function with no glibc when you may use
write systemcall with strout




